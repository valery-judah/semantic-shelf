Designing the `books` module requires a different approach than the `users` module. While the user domain is highly mutable and driven by individual client requests (like updating preferences), the book domain in a recommendation API is typically **read-heavy** and acts as a central, mostly immutable catalog from the perspective of the end-user.

Here is the systems-level design for the `books` module, aligned with your current MVP repository structure and targeting a future PostgreSQL architecture.

### Assumptions and Constraints

* **Read-Only Public Surface**: The public-facing API for this module is strictly read-only (`GET`). Book ingestion, updates, and soft-deletions are assumed to be handled by an out-of-band administrative process, a separate internal service, or a data pipeline.
* **Target Database**: PostgreSQL. We will utilize `ARRAY` types for denormalized multi-value attributes (like authors and genres) to avoid complex join tables for simple metadata, optimizing read performance.
* **Embeddings & Similarity (Target State)**: Since this is a recommendation engine, books will eventually require vector embeddings (e.g., generated by an LLM) for semantic similarity searches. The target state assumes the use of the `pgvector` PostgreSQL extension.
* **Pagination**: For the MVP, standard offset/limit pagination is acceptable. As the dataset grows, cursor-based pagination (using ULID or a sequential timestamp) should be adopted to prevent deep-pagination performance degradation.

---

### Module Directory Structure

We will continue using the flat, domain-aligned structure inside `src/books_rec_api/`.

```text
src/books_rec_api/
├── api/
│   └── routes/
│       └── books.py          # GET endpoints for the catalog
├── schemas/
│   └── book.py           # Pydantic schemas (Read, List)
├── services/
│   └── book_service.py       # Orchestration and business logic
├── repositories/
│   └── books_repository.py   # Data access (MVP in-memory -> Target SQL)
└── models/
    └── book.py           # SQLAlchemy ORM definition

```

---

### Data Models (`models/book.py`) - Target SQLAlchemy Shape

This model is optimized for fast reads. We denormalize `authors` and `genres` into arrays. If your recommendation logic requires strict relational integrity on authors, these would be separated into bridging tables—but for a pure recommendation serving API, denormalized arrays are often faster and sufficient.

```python
from datetime import datetime, timezone
from sqlalchemy import String, Integer, DateTime, Index
from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.orm import Mapped, mapped_column

from books_rec_api.db.base import Base # Placeholder for future DB layer
# from pgvector.sqlalchemy import Vector # Future import for recommendations

class Book(Base):
    __tablename__ = "books"

    # Using ULID or stringified standard ISBN/internal ID
    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    
    title: Mapped[str] = mapped_column(String(255), nullable=False)
    
    # Denormalized arrays for fast read access without joins
    authors: Mapped[list[str]] = mapped_column(ARRAY(String), server_default="{}")
    genres: Mapped[list[str]] = mapped_column(ARRAY(String), server_default="{}")
    
    publication_year: Mapped[int | None] = mapped_column(Integer, nullable=True)
    
    # Target State Recommendation Support:
    # embedding = mapped_column(Vector(384)) # e.g., using all-MiniLM-L6-v2

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(timezone.utc)
    )

    __table_args__ = (
        Index("ix_books_genres", "genres", postgresql_using="gin"), # GIN index for fast array searching
    )

```

---

### Domain Schemas (`schemas/book.py`)

The Pydantic models define the strict contract for serving book data to the client. We do not need a `BookCreate` or `BookUpdate` schema here, as ingestion is handled externally.

```python
from pydantic import BaseModel, ConfigDict, Field

class BookBase(BaseModel):
    title: str
    authors: list[str] = Field(default_factory=list)
    genres: list[str] = Field(default_factory=list)
    publication_year: int | None = None

class BookRead(BookBase):
    id: str
    
    model_config = ConfigDict(from_attributes=True)

class PaginatedBooks(BaseModel):
    items: list[BookRead]
    total: int
    page: int
    size: int

```

---

### Data Access Layer (`repositories/books_repository.py`)

For the MVP, we start with an interface that can be backed by an in-memory dictionary. I am showing the target SQLAlchemy implementation to illustrate how pagination and filtering are handled at the database level.

```python
from typing import Sequence
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from books_rec_api.models.book import Book

class BooksRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_id(self, book_id: str) -> Book | None:
        stmt = select(Book).where(Book.id == book_id)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()

    async def list_books(
        self, 
        limit: int = 20, 
        offset: int = 0, 
        genre: str | None = None
    ) -> tuple[Sequence[Book], int]:
        """
        Returns a tuple of (items, total_count).
        """
        # Base query
        stmt = select(Book)
        count_stmt = select(func.count()).select_from(Book)

        # Apply optional filters
        if genre:
            # PostgreSQL specific: checks if genre is in the genres array
            stmt = stmt.where(Book.genres.any(genre))
            count_stmt = count_stmt.where(Book.genres.any(genre))

        # Add pagination
        stmt = stmt.limit(limit).offset(offset)

        # Execute
        total_result = await self.session.execute(count_stmt)
        total = total_result.scalar_one()

        items_result = await self.session.execute(stmt)
        items = items_result.scalars().all()

        return items, total

```

---

### Business Logic (`services/book_service.py`)

The service layer orchestrates the repository calls and maps the raw data into the Pydantic response models.

```python
from books_rec_api.schemas.book import BookRead, PaginatedBooks
from books_rec_api.repositories.books_repository import BooksRepository

class BookService:
    def __init__(self, repo: BooksRepository) -> None:
        self.repo = repo

    async def get_book(self, book_id: str) -> BookRead | None:
        book = await self.repo.get_by_id(book_id)
        if not book:
            return None
        return BookRead.model_validate(book)

    async def get_books(
        self, 
        page: int = 1, 
        size: int = 20, 
        genre: str | None = None
    ) -> PaginatedBooks:
        
        offset = (page - 1) * size
        items, total = await self.repo.list_books(limit=size, offset=offset, genre=genre)
        
        return PaginatedBooks(
            items=[BookRead.model_validate(item) for item in items],
            total=total,
            page=page,
            size=size
        )

```

---

### API Router (`api/routes/books.py`)

The router exposes the catalog. Since these are generic catalog reads, these endpoints generally do not require the `get_external_idp_id` authentication dependency, allowing them to be public (or protected by a simpler API key depending on your business model).

```python
from fastapi import APIRouter, Depends, HTTPException, status, Query

from books_rec_api.schemas.book import BookRead, PaginatedBooks
from books_rec_api.services.book_service import BookService
from books_rec_api.dependencies.books import get_book_service # To be implemented

router = APIRouter(prefix="/books", tags=["books"])

@router.get("", response_model=PaginatedBooks)
async def list_books(
    page: int = Query(1, ge=1, description="Page number"),
    size: int = Query(20, ge=1, le=100, description="Items per page"),
    genre: str | None = Query(None, description="Filter by genre"),
    svc: BookService = Depends(get_book_service),
) -> PaginatedBooks:
    """Retrieve a paginated list of books from the catalog."""
    return await svc.get_books(page=page, size=size, genre=genre)

@router.get("/{book_id}", response_model=BookRead)
async def get_book_by_id(
    book_id: str,
    svc: BookService = Depends(get_book_service),
) -> BookRead:
    """Retrieve a specific book's metadata."""
    book = await svc.get_book(book_id)
    if not book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found"
        )
    return book

```
