Designing the `books` module requires a different approach than the `users` module. While the user domain is highly mutable and driven by individual client requests (like updating preferences), the book domain in a recommendation API is typically **read-heavy** and acts as a central, mostly immutable catalog from the perspective of the end-user.

Here is the systems-level design for the `books` module, aligned with your current MVP repository structure and synchronous PostgreSQL architecture.

### Assumptions and Constraints

* **Read-Only Public Surface**: The public-facing API for this module is strictly read-only (`GET`). Book ingestion, updates, and soft-deletions are assumed to be handled by an out-of-band administrative process, a separate internal service, or a data pipeline.
* **Target Database**: PostgreSQL. We will utilize `ARRAY` types for denormalized multi-value attributes (like authors and genres) to avoid complex join tables for simple metadata, optimizing read performance.
* **Embeddings & Similarity (Target State)**: Since this is a recommendation engine, books will eventually require vector embeddings (e.g., generated by an LLM) for semantic similarity searches.
* **Pagination**: For the MVP, standard offset/limit pagination is acceptable. As the dataset grows, cursor-based pagination should be adopted to prevent deep-pagination performance degradation.
* **Synchronous Processing**: The current application architecture relies on synchronous SQLAlchemy `Session` operations, so the database layer and services will be implemented synchronously to match existing patterns (like `UsersRepository`).

---

### Module Directory Structure

We will integrate the `books` domain into the existing flat, domain-aligned structure inside `src/books_rec_api/`.

```text
src/books_rec_api/
├── api/
│   └── routes/
│       └── books.py          # GET endpoints for the catalog
├── dependencies/
│   └── books.py              # DI wiring for books module
├── schemas/
│   └── book.py               # Pydantic schemas (Read, List)
├── services/
│   └── book_service.py       # Orchestration and business logic
├── repositories/
│   └── books_repository.py   # Data access (Synchronous SQL)
└── models.py                 # (Existing) SQLAlchemy ORM definitions - appending Book here
```

---

### Data Models (`models.py`)

This model is optimized for fast reads. We denormalize `authors` and `genres` into arrays. We append this to the existing `models.py`.

```python
from datetime import datetime, timezone
from sqlalchemy import String, Integer, DateTime, Index
from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.orm import Mapped, mapped_column

# Added to the existing Base in models.py
class Book(Base):
    __tablename__ = "books"

    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    title: Mapped[str] = mapped_column(String(255), nullable=False)
    
    # Denormalized arrays for fast read access without joins
    authors: Mapped[list[str]] = mapped_column(ARRAY(String), server_default="{}")
    genres: Mapped[list[str]] = mapped_column(ARRAY(String), server_default="{}")
    
    publication_year: Mapped[int | None] = mapped_column(Integer, nullable=True)

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(timezone.utc)
    )

    __table_args__ = (
        Index("ix_books_genres", "genres", postgresql_using="gin"), # GIN index for fast array searching
    )
```

---

### Domain Schemas (`schemas/book.py`)

The Pydantic models define the strict contract for serving book data to the client.

```python
from pydantic import BaseModel, ConfigDict, Field

class BookBase(BaseModel):
    title: str
    authors: list[str] = Field(default_factory=list)
    genres: list[str] = Field(default_factory=list)
    publication_year: int | None = None

class BookRead(BookBase):
    id: str
    
    model_config = ConfigDict(from_attributes=True)

class PaginatedBooks(BaseModel):
    items: list[BookRead]
    total: int
    page: int
    size: int
```

---

### Data Access Layer (`repositories/books_repository.py`)

We align with the synchronous SQLAlchemy patterns established in `UsersRepository`.

```python
from typing import Sequence
from sqlalchemy import select, func
from sqlalchemy.orm import Session

from books_rec_api.models import Book

class BooksRepository:
    def __init__(self, session: Session) -> None:
        self.session = session

    def get_by_id(self, book_id: str) -> Book | None:
        return self.session.get(Book, book_id)

    def list_books(
        self, 
        limit: int = 20, 
        offset: int = 0, 
        genre: str | None = None
    ) -> tuple[Sequence[Book], int]:
        """
        Returns a tuple of (items, total_count).
        """
        stmt = select(Book)
        count_stmt = select(func.count()).select_from(Book)

        if genre:
            stmt = stmt.where(Book.genres.any(genre))
            count_stmt = count_stmt.where(Book.genres.any(genre))

        stmt = stmt.limit(limit).offset(offset)

        total = self.session.execute(count_stmt).scalar_one()
        items = self.session.scalars(stmt).all()

        return items, total
```

---

### Business Logic (`services/book_service.py`)

The service layer orchestrates the repository calls and maps the raw data into the Pydantic response models.

```python
from books_rec_api.schemas.book import BookRead, PaginatedBooks
from books_rec_api.repositories.books_repository import BooksRepository

class BookService:
    def __init__(self, repo: BooksRepository) -> None:
        self.repo = repo

    def get_book(self, book_id: str) -> BookRead | None:
        book = self.repo.get_by_id(book_id)
        if not book:
            return None
        return BookRead.model_validate(book)

    def get_books(
        self, 
        page: int = 1, 
        size: int = 20, 
        genre: str | None = None
    ) -> PaginatedBooks:
        
        offset = (page - 1) * size
        items, total = self.repo.list_books(limit=size, offset=offset, genre=genre)
        
        return PaginatedBooks(
            items=[BookRead.model_validate(item) for item in items],
            total=total,
            page=page,
            size=size
        )
```

---

### API Router (`api/routes/books.py`)

The router exposes the catalog. These endpoints use standard dependency injection, similar to `users.py`.

```python
from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status, Query

from books_rec_api.schemas.book import BookRead, PaginatedBooks
from books_rec_api.services.book_service import BookService
from books_rec_api.dependencies.books import get_book_service

router = APIRouter(prefix="/books", tags=["books"])

@router.get("", response_model=PaginatedBooks)
def list_books(
    svc: Annotated[BookService, Depends(get_book_service)],
    page: int = Query(1, ge=1, description="Page number"),
    size: int = Query(20, ge=1, le=100, description="Items per page"),
    genre: str | None = Query(None, description="Filter by genre"),
) -> PaginatedBooks:
    """Retrieve a paginated list of books from the catalog."""
    return svc.get_books(page=page, size=size, genre=genre)

@router.get("/{book_id}", response_model=BookRead)
def get_book_by_id(
    book_id: str,
    svc: Annotated[BookService, Depends(get_book_service)],
) -> BookRead:
    """Retrieve a specific book's metadata."""
    book = svc.get_book(book_id)
    if not book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found"
        )
    return book
```
